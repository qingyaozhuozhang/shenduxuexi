> # 深度学习概念
>
> > 1.深度学习定义
> >
> > 定义：一般是指通过徐莲多层网络结构对位置数据机型分类或回归
> >
> > 分类：
> >
> > （1）有监督学习方法 —— 深度前馈网络、卷积神经网络、循环神经网络等
> >
> > （2）无监督学习方法 —— 深度信念网、深度玻尔兹曼机、深度自编码器等
> >
> > 思想：通过构建多层玩过，对目标进行多层表示，以期通过多层的高层次特征来标识数据的抽象语义细腻，获得更好的特征性
> >
> > 2.深度学习应用
> >
> > （1）图像处理领域应用
> >
> > > -1 图像分类（物体识别）：整幅图像的分类或识别
> > >
> > > -2 物体检测：检测图像中物体的位置进而识别物体
> > >
> > > -3 图像分割：对图像中的特定物体按边缘进行分割
> > >
> > > -4 图像回归：预测图像中物体组成部分的坐标
>
> > （2）语音识别领域主要应用
> >
> > > -1 语音识别：将语音识别为文字
> > >
> > > -2 声纹识别：识别是哪个人的声音
> > >
> > > -3 语音合成：根据文字合成特定人的语音
>
> > （3）自然语言处理领域主要应用
> >
> > > -1 语言模型：根据之前词预测下一个单词
> > >
> > > -2 情感分析：分析文本能体现的情感
> > >
> > > -3 神经及其翻译：基于统计语言模型的多语种互译
> > >
> > > -4 神经自动摘要：通过阅读文本回答问题、完成选择题或完型填空
> > >
> > > -5 机器阅读理解：通过阅读文本回答问题、完成选择题或完型天空
> > >
> > > -6 自然语言推理：根据一句话（前提）推理出领一句话（结论）
>
> > 综合应用
> >
> > （1）图像描述：根据图像给出图像的描述句子
> >
> > （2）可视问答：根据图像或视频回答问题
> >
> > （3）图像生成：根据文本描述生成图像
> >
> > （4）视频生成：根据故事自动生成视频
>
> # 神经网络基础
>
> ## 1.单个神经元
>
> > **感知机**
> >
> > 数学模型（MP模型）
>
> <img src="C:\sum\Laboratory\knowledge\知识点\picture\deepseek.png">
>
> > （1）x：输入
> >
> > （2）ω：权重
> >
> > （3）b：偏差
> >
> > （4）激活函数φ：一个非线性函数，目的是将输入进行变化映射，跌出输出信号
> >
> > 常用的激活函数
> >
> > > -1     sigmoid —— 用于隐藏神经元的输出
> > >
> > > 1）sigmoid的表现形式为：
>
> <img src="C:\sum\Laboratory\knowledge\知识点\picture\sigmoid.png">
>
> > > sigmoid变换产生一个值为0到1之间平滑的范围。如果是非常大的负数输出就是0；如果是非常大的正数，输出就是1
> > >
> > > 2）缺陷：
> > >
> > > 当输入非常大或者非常小的时候，这些神经元的梯度是接近于0的，从图中可以看出梯度的趋势。sigmoid的输出不是0均值，这会导致后一层的神经元将得到上一层输出的非0均值的信号作为输入
> > >
> > > -2      ReLu（整流线型单位）—— 用于隐藏神经元输出
> > >
> > > 1）表现形式
>
> <img src="C:\sum\Laboratory\knowledge\知识点\picture\ReLu.png">
>
> > > 当x>0时，函数的输出值为x;当x<=0时，输出值为0
>
> ## 2.神经元的拟合原理
>
> > 模型每次的学习都是为了调整ω和b从而得到一个合适的值，最终由这个值配合运算公式所形成的逻辑就是神经网络模型。这个调整的过程称为拟合
> >
> > （1）正向传播：输入层通过隐藏层到输出层的运动（加入一个训练过程，通过反向误差传递的方法让模型自动来修正，最终得到合适的 ω 和 b）
> >
> > （2）反向传播：使用成本函数梯度的权重的更新称为反向传播（当建立神经网络的时候，会初始化一个权重和偏差，在一次迭代的过后，计算出网络的错误，然后将该错误与成本函数的梯度一桶反馈给网络用来更新网络中的群众，以减少后续迭代的错误。）（在估计权重的时候的必要过程，可被称为BP算法 。深度学习的目的即使通过最小化损失函数，来估计神经网络的权重）
> >
> > 通常BP的步骤为：
> >
> > > -1 明确损失函数
> > >
> > > -2 明确参数调整策略
>
> > （3）激活函数：主要作用就是加入**非线性**因素，以解决线性模型表达能力不足的缺陷（可以吧当前特征空间通过一定的线性映射转换到另一个空间，然数据能够更好的被分类）
> >
> > （4）处理分类：softmax回归，对一些数据进行多种分类
>
> <img src="C:\sum\Laboratory\knowledge\知识点\picture\softmax.png">
>
> > 其中zi为第i个节点的输出值，C为输出节点的个数，即分类的类别个数，通过softmax函数就可以将多分类的输出值转换为范围在[0,1]和为1的概率分布。把所有制的e的n次方计算出来，求和后算每个值占的比率，保证总和为1，一般就可以认为softmax得出的是概率
> >
> > （5）损失函数：用于描述模型预测值与真实值的差距大小。一般有两种比较常见的算法——均值平方差（MSE）和交叉熵（在大部分监督学习算法中都会有一个目标函数，算法对该目标函数进行优化，称为优化算法的过程，而损失函数就是这个目标函数）
> >
> > > -1 均值平方差
>
> <img src="C:\sum\Laboratory\knowledge\知识点\picture\Mean_Squared.png">
>
> > > -2 交叉熵损失函数：预测输入样本属于某一类的概率。公式中y代表真实值分类（0或1），a代表预测值。交叉熵也是值越小，代表预测结果越准。
> > >
> > > 注意：这里用于计算的a也是通过分布统一化处理的（或者是经过Sigmoid函数激活等），取值范围在0~1之间。
>
> <img src="C:\sum\Laboratory\knowledge\知识点\picture\Cross_Entropy.png">
>
> > > 注意：损失算法的选取
> > >
> > > ​			损失函数的选取取决于输入标签数据的类型：如果输入的是示数、无界的值，损失函数使用MSE;如果输入标签是位矢量（分类label），使用交叉熵会更合适
> > >
> > > ​			均方误差作为损失函数收敛速度慢，可能会陷入局部最优解，而交叉熵作为损失函数的收敛速度比均方误差块，且较为容易找到函数最优解
> > >
> > > ​			损失函数越小说明网络模型越好
> > >
> > > -3 回归损失函数
> > >
> > > > ​		均方误差损失函数
>
> <img src="C:\sum\Laboratory\knowledge\知识点\picture\MSE.png">
>
> > > > ​	def mean_squared_error(y_true,y_pred):
> > > >
> > > > ​				return np.mean(np.square(y_pred  -  y_true) , axis = -1)
> > > >
> > > > ​		平均绝对误差损失函数
>
> <img src="C:\sum\Laboratory\knowledge\知识点\picture\MAE.png">
>
> > > > ​	def mean_absolute_error(y_true , y_pred):
> > > >
> > > > ​				return np.mean(np.abs(y_pred  -  y_true), axis = -1)
> > > >
> > > > ​		均方误差对数损失函数
>
> <img src="C:\sum\Laboratory\knowledge\知识点\picture\MSLE.png">
>
> > > > ​	def mean_squared_logarithmic_error(y_true , y+pred):
> > > >
> > > > ​			first_log = np.log(np.clip(y_pred , 10e - 6 , None) + 1)
> > > >
> > > > ​			second_log = np.log(np.clip(y_true , 10e -6 , None) + 1)
> > > >
> > > > ​			return np.mean(np.square(first_log - second_log), axis = -1)
> > > >
> > > > ​		平均绝对百分比误差损失函数
>
> <img src="C:\sum\Laboratory\knowledge\知识点\picture\MAPE.png">
>
> > > > ​	def mean_absolute_percentage_error(y_true , y_pred):
> > > >
> > > > ​			diff = np.abs((y_pred - y_true) / np.clip(np.abs(y_true) , 10e-6 , None))
> > > >
> > > > ​			return 100*np.mean(diff , axis=-1)
> > >
> > > -4 	分类损失函数
> > >
> > > > ​		Logistic损失函数
>
> <img src="C:\sum\Laboratory\knowledge\知识点\picture\Logistic.png">
>
> > > > ​	  负对数似然损失函数
>
> <img src="C:\sum\Laboratory\knowledge\知识点\picture\Likelihood.png">
>
> > > > ​		交叉熵损失函数
> > > >
> > > > Logisitc损失函数和负对数似然损失函数只能处理二分类问题，对于啷个分类扩展到M个分类，使用交叉熵损失函数
>
> <img src="C:\sum\Laboratory\knowledge\知识点\picture\Entropy.png">
>
> > > > ​		def cross_entropy(y_true  ,  y_pred):
> > > >
> > > > ​				return -np.mean(y_true  *  np.log(y_pred  +  10e-6))
> > > >
> > > > ​		Hinge损失函数
> > >
> > > > 运用Hinge苏轼的典型分类其实SVM算法，因为Hinge损失可以用来解决间隔最大化问题。当分类模型需要硬分类结果的，例如分类结果是0或1、-1或1的二分类数据
>
> <img src="C:\sum\Laboratory\knowledge\知识点\picture\Hinge.png">
>
> > > > ​		def hinge(y_true , y_pred):
> > > >
> > > > ​				return np.mean(np.maximum(1 - y_true * y_pred , 0) , axis = -1)
> > > >
> > > > ​		指数损失函数
> > > >
> > > > 使用指数损失函数的典型分类其实AdaBoost算法
>
> <img src="C:\sum\Laboratory\knowledge\知识点\picture\Exponential.png">
>
> > > > ​		def exponential(y_true , y_pred):
> > > >
> > > > ​				return np.sum(np.exp(-y_true * pred))
>
> **神经网络中常用的损失函数**
>
> > 自定义损失函数需要考虑输入的数据形式和对损失函数求导的算法。自定义损失函数其实是有难度的，在实际工程项目上，结合激活函数来选择损失函数是常见的做法，常用的组合有以下3种：
> >
> > 1	ReLU	+	MSE
> >
> > 均方误差损失函数无法处理梯度消失问题，而使用Leak ReLU激活函数能够减少计算梯度消失的问题
> >
> > 2	Sigmoid	+	Logistic
> >
> > Sigmoid函数会引起梯度消失问题，而类Logistic可以在一定程度上避免了梯度消失，所以我们经常可以看到Sigmoid激活函数 + 交叉熵损失函数的组合
> >
> > 3	Softmax	+	Logistic
> >
> > 在数学上，Softmax激活函数会返回输出类的互斥概率分布，也就是能把离散的输出转换为一个同分布互斥的概率，如（0.2,0.8）。另外，Logistic损失是基于概率的最大似然估计函数而来的，因此输出概率化能够更加方便优化算法进行求导和计算，所以我们可以看到输出层使用Softmax激活函数 + 交叉熵损失函数的组合
>
> **激活函数、损失函数、优化函数的区别**
>
> > 1.激活函数：将神经网络上一层的输入，经过神经网络层的非线性变换转换后，通过激活函数，得到输出，常见的激活函数包括：sigmoid,tanh,relu等
> >
> > 2.损失函数：度量神经网络的输出的预测值，与实际值之间的差距的一种方式，常见的损失函数包括：最小二乘损失函数、交叉熵损失函数、回归中使用的smooth L1损失函数等
> >
> > 3.优化函数：也就是如何把损失值从神经外那个罗的最外层传递到最前面。如最基础的梯度湘江算法，随机梯度下降算法，批量梯度下降算法，带东来跟的梯度下降算法，Adagrad，Adadelta，Adam等
>
> > （6）优化方法总结
> >
> > > -1	梯度下降方法
> > >
> > > 最基本的：SGD、BGD、MBGD
> > >
> > > > 1）	随机梯度下降法(SGD)
> > > >
> > > > 每次迭代（更新参数）只使用单个训练样本
> > > >
> > > > 缺点：
> > > >
> > > > 1)	由于单个样本的随机性，目标损失函数值会剧烈波动。可能会专挑的更好的局部最小值。也可能会使得训练永远不会收敛
> > > >
> > > > 2） 一次迭代只计算一张图片，没有发挥GPU并运算的优势，使得整体计算的效率不高
>
> <img src="C:\sum\Laboratory\knowledge\知识点\picture\SGD.png">
>
> > > > 2 ) 	批量梯度下降法(BGD)
> > >
> > > > 每次迭代更新中使用所有的训练样本
> > > >
> > > > 优缺点分析：BGD能保证收敛到凸误差表面的全局最小值。但每迭代一次，需要用到训练集中的所有数据，迭代速度可能很慢
>
> <img src="C:\sum\Laboratory\knowledge\知识点\picture\BGD.png">
>
> > > > 3）	小批量梯度下降法(MBGD)（常用）
> > > >
> > > > 每次迭代使用功能batch_size个训练样本进行计算
> > > >
> > > > 优缺点分析：每次迭代使用多个样本，所以MBGD比SGD收敛更稳定，也能避免BGD在数据集过大时迭代速度慢的问题
>
> <img src="C:\sum\Laboratory\knowledge\知识点\picture\MBGD.png">
>
> > > > 4)	Momentum动量梯度下降
> > > >
> > > > 当前参数更新方向不仅与当前的梯度有关，也受历史的加权平局梯度影响。对于梯度指向相同方向的维度，动量会积累并增加，而对与梯度改变方向的梯度，动量会减少更新。这也使得收敛速度加快，同时又不至于摆动幅度太大
> > > >
> > > > 作用：加快学习速度，还有一定摆脱局部最优的能力
> > > >
> > > > 获得了更快的收敛和减少的振荡
>
> <img src="C:\sum\Laboratory\knowledge\知识点\picture\Momentum.png">
>
> > > > Adam优化器
> > > >
> > > > Adam是另一种参数自适应学习率的方法，相当于RMSprop + Momentum，利用梯度的一阶估计和二姐矩估计动态整理每个参数的学习率
>
> <img src="C:\sum\Laboratory\knowledge\知识点\picture\Adam.png">
>
> 
>
> ## 3.多层神经网络（深度神经网络）
>
> > 输入层：接收输入的那一层，本质上是网络的第一层
> >
> > 输出层：生成输出的那一层，本质上是网络的最后一层
> >
> > 隐藏层：处理信号的中间层，隐藏层对传入的数据做特定的任务并生成输出，传递到下一层
> >
> > 神经网络的常用模型
> >
> > （1）前馈网络（2）记忆网络（3）图网络
>
> > （1）传统前馈神经网络——对隐藏概念的引入
> >
> > 单个神经元的拟合仅适用于线性可分（可被直线或平面分割）的情况
> >
> > 对于高维非线性问题，我们引入了一个隐藏层概念来解决问题：将“线性不可分”的数据映射到高维空间来，使**映射**后的数据变得“线性可分”
> >
> > 理论上通过升级空间可分的结构，是可以将任何问题分开的（但是分类效果的增强会越来越不明显）
> >
> > （2）卷积神经网络（CNN）——隐藏层的常见功能层
> >
> > 除了输入层与输出层之外，都可以被泛称隐藏层。隐藏层不直接接收外界的信号，也不直接向外界发送信号
> >
> > 隐藏层在神经网络中的作用，就是中间的黑盒子，可以认为是其他的不同功能的一个总称
> >
> > CNN特点：
> >
> > > ​		1 能够有效的将大数据量的图片降维成小数据量
> > >
> > > ​		2 能够有效的保留图片特征，复合图片处理的原则
> >
> > CNN两大核心：
> >
> > 局部连接和权值共享
> >
> > > ​		1 通过卷积操作实现局部连接，这个局部区域的大小就是滤波器fiter，避免了全连接中参数过多造成无法计算的情况
> > >
> > > ​		2 再通过参数共享来缩减实际参数的数量，为实现多层网络提供了可能
> > >
> > > 解释：
> > >
> > > ​		1 局部连接：
> > >
> > > ​		一般认为图像的空间联系是局部的像素联系比较密切，而距离较远的像素相关性较弱，因此，每个神经元没必要对全局图像进行感知，只要对局部进行感知，然后在更高层将局部的信息综合起来得到全局信息。利用卷积层实现：（特征映射，每个特征映射是一个神经元阵列）：从上一层通过局部卷积滤波器提取局部特征。卷积层紧跟着一个用来求局部平均与二次提取的计算层，这种二次特征提取结构减少了特征分辨率
> > >
> > > ​		即网络部分连通，每个神经元只与上一层的部分神经元相连，只感知局部，而不是整幅图像
> > >
> > > ​		2 参数共享
> > >
> > > ​		在局部连接中，每个神经元的参数都是一样的，即：同一个卷积核在图像中都是共享的（卷积操作实际是在提取一个个局部信息，而局部信息的一些统计特性和其他部分是一样的，也就一维这这部分学到的特征也可以用到另一部分上。所以对图像上的所有位置，都能使用同样的学习特征）。造成的问题：提取特征补充分，可以通过增加多个卷积核来弥补，可以学习多种特征
> >
> > > ​	卷积网络时由卷积层、子采样层、全连接层交叉堆叠而成（1）趋向于小卷积、大深度（2）趋向于全卷积
> > >
> > > ​	一个卷积块为连续M个卷积层和b个汇聚层，一个卷积网络中可以堆叠N个连续的卷积块，然后接着K个全连接层
> > >
> > > -1 卷积层
> > >
> > > ​	卷积是一种有效提取图片特征的方法。一般用一个正方形卷积核，遍历图片上的每一个像素点。图片与卷积核重合区域相对应的每一个像素值，乘卷积核内相对应点的权重，然后求和，再加上偏置后，最后得到输出图片中的一个像素值
> > >
> > > > 1	卷积核
> > > >
> > > > 卷积层的功能是对输入数据进行特征提取，其内部包含多个卷积核，组成卷积核的每个元素都对应一个权重系数W和一个偏差量b,类似于一个前馈神经网络的神经元（一个卷积核只能提取一个特征）
> > > >
> > > > 卷积核在工作时，会有规律地扫过输入特征，在感受野内对输入特征做矩阵元素惩罚求和并叠加偏差量
> > > >
> > > > ​	由于图片分为灰度图和彩色图，卷积核可以是单个也可以是多个，因此卷积操作可以分为三种情况：
> > > >
> > > > （1）单通道输入，单卷积核
> > > >
> > > > ​	单通道是灰度图，但卷积核值卷积核个数是1个。示例：5x5x1灰度图片，5x5表示分辨率，1表示单通道。3x3x1的卷积核，1则标示偏置项（就运算完以后，要再多加上1）（不是行列式计算）
> > > >
> > > > （2）多通道输入，单卷积核
> > > >
> > > > ​	多通道一般指RGB三个颜色组成的彩色图。卷积核的深度（通道数）（就是卷积核内部的数字不同，总共有3种）应该等于输入图片的通道数，所以使用3x3x3的卷积核，最后一个3表示匹配输入图像的3个通道，这样这个卷积核有三通道，每个通道都会随机生成9个待优化的参数，一共有27个待优化参数 w 和一个偏置 b
> > > >
> > > > （3）多通道输入，多卷积核
> > > >
> > > > ​	就先执行多通道输入，单卷积核的操作。最后将相同size的output1和output2进行堆叠，就得到多个通道的输入output（偏置数 = 卷积核数）
> > > >
> > > > 2	卷积层参数
> > > >
> > > > 卷积层参数包括卷积核大小、补偿和填充
> > > >
> > > > ​	卷积核越大，可提取的输入特征越复杂
> > > >
> > > > ​	卷积步长定义了卷积核相邻两次扫过特征图时位置的距离（卷积步长为1时，卷积核会逐个扫过特征图的元素，补偿为n时会在下一次扫扫描跳过n-1个像素）
> > > >
> > > > ​	填充是在特征图通过卷积核之前认为增大其尺寸以抵消计算中尺寸收缩影响的方法（随着卷积层的堆叠），常见的填充方法为按0填充和重复边界值填充
> > > >
> > > > （1）全零填充padding='same'，会自动对原图进行全0填充，当步长为1时，可以保证输出的图片与输入的图片尺寸一直，示例：
> > > >
> > > > layers.Conv2D(48 , kernel_size=3 , strides=1 , padding='same')（48为卷积核个数）
> > > >
> > > > （2）不填充padding='valid'
> > > >
> > > > 使用valid时，不尽兴任何填充，直接进行卷积，这是layers.Conv2D()默认的方式
> > > >
> > > > layers.Conv2D(48 , kernel_size=3 , strides=1 , padding='valid')
> > > >
> > > > （3）自定义填充padding=[[0,0],[上，下],[左，右],[0,0]]
> > > >
> > > > 一般是从上下左右四个方向进行填充，且左、右填充的列数一般相同，上，下填充的行数也应该相同（往外扩增）
> > > >
> > > > layers.Conv2D(48 , kernel_size=3 , strides=1 , padding=[[0,0],[1,1],[1,1],[0,0]])
> > > >
> > > > > 依据层数和目的可分为四类：
> > > > >
> > > > > 1）	有效填充：完全不使用填充，卷积核只允许访问特征图宏包含完整感受野的位置。输出的所有像素都是输入中相同数量像素的函数
> > > > >
> > > > > 2)		相同填充/半填充：只进行足够的填充来保持输出和输入的特征图尺寸相同。相同填充下特征图的尺寸不会缩减但输入像素中靠近边界的部分相比于中间部分对于特征图的影响更小
> > > > >
> > > > > 3）	全填充：进行足够多的填充使得每个像素在每个方向上被访问的次数相同
> > > > >
> > > > > 4）	任意填充：介于有效填充和全填充之间
>
> > > > 3	激励函数
> > > >
> > > > 激励函数操作通常在卷积核之后，一些使用预激活技术的算法将激励函数置于卷积核之前
> > > >
> > > > 4	滤波器
> > > >
> > > > CNN中的滤波器与加权矩阵一样，它与输入图像的一部分相乘以产生一个回旋输出
>
> > （3）池化层
> >
> > 在卷积层进行特征提取后，输出的特征图会被传递至池化层进行特征选择和信息过滤。池化层包含预设定的池化函数，其功能是将特征图中单个点的结果替换为其相邻区域的特征图统计量
> >
> > 本质其实就是降采样，选择某种方式对其进行降维压缩，以加快运算速度,使卷积神经网络抽取特征时保证特征局部不变性
> >
> > 采用较多的一种池化过程叫最大池化，另一种是平均池化
> >
> > 池化层没有参数
> >
> > 作用:
> >
> > > （1）保留主要特征的同时减少参数和计算量，放置过拟合
> > >
> > > （2）不变性：平移，旋转，尺度
>
> > （4）全连接层
> >
> > 之所以叫全连接，是因为每个神经元与前后相邻层的每一个神经元都有连接关系
> >
> > 一般会把卷积输出的二维特征图转化成一维的一个向量
> >
> > 在实际应用中，会现对原始图像进行卷子特征提取，把提取到的特征喂给全连接网络，再让全连接网络计算出分类评估值
>
> ------
>
> ## 4.过拟合与欠拟合问题
>
> > 参数过多（过少）
> >
> > 欠拟合的解决方法：
> > 1． 增加新特征，可以考虑加入进特征组合、高次特征，来增大假设空间
> > 2． 添加多项式特征，这个在机器学习算法里面用的很普遍，例如将线性模型通过添加二次项或者三次项使模型泛化能力更强
> > 3． 减少正则化参数，正则化的目的是用来防止过拟合的，但是模型出现了欠拟合，则需要减少正则化参数
> > 4． 使用非线性模型，比如核SVM 、决策树、深度学习等模型
> > 5． 调整模型的容量(capacity)，通俗地，模型的容量是指其拟合各种函数的能力
> > 6． 容量低的模型可能很难拟合训练集；使用集成学习方法，如Bagging ,将多个弱学习器Bagging
> >
> > 过拟合的解决方法：
> > 1． 换一个复杂度低一点的模型或正则化，对神经网络来说，使用参数量少一点的网络。或使用正则化，通过引入范数，增强模型的泛化能力。
> > 2． 使用不同分布的数据来训练。如数据增强，预训练等。
> > 3． 使用图像裁剪等方法对图像进行预处理。
> > 4． 及时地停止训练。如何判断什么时候该停止训练？使用K折交叉验证，若训练损失还在减少，而验证损失开始增加，则说明开始出现过拟合。
> > 5． 通过每次训练时舍去一些节点来增强泛化能力（dropout）。
>
> ------
>
> ## 5.神经网络
>
> > 1.MLP（多层感知器）
> >
> > 由于单个神经元无法完成复杂的任务，所以我们使用对战神经元的方法来生成我们所需要的输出。在最简单的神经网络中，包含一个输入层、一个输出层、一个隐藏层。每一个层中包含有若干个神经元，每一层的神经元连接站着下一层的所有神经元，这样的网络也叫做全完连接网络
> >
> > 2.梯度下降
> >
> > 梯度下降是最小化成本的优化算法，找到最小化的损失函数和模型参数值
> >
> > 3.学习率
> >
> > 学习率是每次迭代中成本函数最小化的亮，梯度下降到成本函数最小值所对应的速率就是学习率
> >
> > 4.批次
> >
> > 在训练神经网络的同时，不用一次发送整个输入，我们将输入分成几个随机大小相等的块。与整个数据集一次性馈送到网络时建立的模型相比，批量训练数据使得模型更加广义化
> >
> > 5.周期
> >
> > 一个周期是指这个输入数据的单词向前和向后传递（适当增加周期数量可以让网络更加准确，但是会增加网络融合时间）
> >
> > 6.丢弃
> >
> > 在训练的过程中，隐藏层的神经元会有一定数量的被丢弃掉。这意味着训练发生在神经网络不同组合的神经网络的几个架构上，可以将Dropout视为一种总和技术，然后将多个网络的输出用于产生最终输出
>
> > 一.超参数
> >
> > 1.什么是超参数？
> >
> > 在机器学习中，超参数是在开始学习过程之前设置值的参数，而不是通过训练得到的参数数据，示例：学习率、梯度下降法迭代的数量、隐藏层实木、隐藏层单元数目、激活函数
> >
> > 2.如何寻找超参数的最优值？
> >
> > （1）猜测和检查（2）网络搜索（让计算机尝试在一定范围内均匀分布的一组值）（3）随机搜索（4）贝叶斯优化（5）MITIE方法（局部优化）（6）LIPO的全局优化方法
> >
> > 3.超参数搜索一般过程？
> >
> > （1）将数据集划分成训练集、验证集及测试集
> >
> > （2）在训练集上根据模型的性能指标对模型参数进行优化
> >
> > （3）在验证集上根据模型的性能指标对模型的超参数进行搜索
> >
> > （4）步骤2和步骤3交替迭代，最终确定模型的参数和超参数，在测试集中验证评价模型的优劣
> >
> > 二.网络参数量与计算量
> >
> > 卷积参数 = 卷积核长度 x 卷积核宽度 x 输入通道数 x 输出通道数 + 输出通道数（偏置）
> >
> > 卷积计算量 = 输出数据大小 x 卷积核的尺度 x 输入通道数
> >
> > 三.卷积神经网络训练：
> >
> > 训练基本流程
> >
> > （1）用随机数初始化所遇的卷积核和参数/权重
> >
> > （2）训练图片作为输入，执行前向步骤（卷积，ReLU，池化以及全连接层的前向传播）并计算每个类别的对应输出概率
> >
> > （3）计算输出层的总务查
> >
> > （4）反向传播算法计算误差相对于所有权重的梯度，并用梯度下降算法更新宿友的卷积核和参数/权重的值，以使输出误差最小化
> >
> > 注意：卷积核个数、卷积核尺寸、网络架构这些参数，是在Step1之前就已经固定的，且不会再训练过程中改变——只有卷积核矩阵和神经元权重会更新
> >
> > 四.CNN详细求解
> >
> > ​	CNN本质上是一种输入到输出的映射，它能够学习大量的输入与输出之间的映射关系，而不需要任何输入和输出之间的精确的数学表达式，只要用已知的模式对卷积网络加以训练，网络就具有输入输出对之间的映射能力
> >
> > ​	卷积网络执行的是监督训练，所以其样本集是由形如：（输入向量，理想输出向量）的向量对构成的
> >
> > （1）参数初始化
> >
> > ​	在开始训练前，所有的权都应该用一些不同的随机数进行初始化。“小随机数”用来保证忘咯不会因权值过大而进入饱和状态，从而导致训练失败；“不同”用来保证网络可以正常地学习，实际上，如果用相同的数去初始化权矩阵，则网络无学习能力
> >
> > （2）训练过程包括四步
> >
> > > ​	-1 第一阶段：前向传播阶段
> > >
> > > ​		从样本集中取一个样本，输入网络
> > >
> > > ​		计算相应的时机输出 ; 在此阶段信息从输入层经过逐级的变换，传送到输出层，这个过程也是网络在完成训练之后正常执行时执行的过程
> > >
> > > ​	-2 第二阶段：后向传播阶段
> > >
> > > ​		计算实际输出与相应的理想输出的差
> > >
> > > ​		按照极小化误差的方法调整权值矩阵
> >
> > 网络的训练过程如下：
> >
> > 1.选定训练组，从样本集中分别随机地寻求N个样本作为训练组
> >
> > 2.将各权值、阈值、置成小的接近于0的随机值，并初始化精度控制参数和学习率
> >
> > 3.从训练组中取一个输入模式加到网络，并给出它的目标输出向量
> >
> > 4.计算出中间层输出向量，计算出网络的实际输出向量
> >
> > 5.将输出向量中的元素与目标向量中的元素进行比较，计算出输出误差；对于中间层的隐单元也需要计算出误差；
> >
> > 6.依次计算出各权值的调整量和阈值的调整量
> >
> > 7.调整权值和调整阈值
> >
> > 8.当经历（7）后，判断指标是否满足精度要求，如果不满足，则返回（3），继续迭代；如果满足就进入下一步
> >
> > 9.训练结束，将权值和阈值保存在文件中。这时可以认为各个权值已经达到稳定，分类器已经形成，再一次进行训练，直接从文件导出权值和阈值进行训练，不需要进行初始化
>
> 神经元个数 = 卷积核数量 x 输出特征图宽度 x 输出特征图高度
>
> 卷积层可训练参数数量 = 卷积核数量 x （卷积核宽度 x 卷积核高度 +1）（1表示偏置）
>
> 汇聚层可训练参数数量 = 卷积核数量 x(1+1)(两个1分别表示相加后的系数和偏置，有的汇聚层无参数)
>
> 连接数 = 卷积核数量 x （卷积核宽度 x 卷积核高度 +1）x 输出特征图宽度 x 输出特征图高度（1表示偏置）
>
> 全连接层连接数 = 卷积核数量 x (输入特征图数量 x 卷积核宽度 x 卷积核高度 + 1)（输出特征图尺寸为1 x 1）
>
> **总结**
>
> CNN的基本原理：
>
> 1.卷积层——主要作用是保留图片的特征
>
> 2.池化层——主要作用是吧数据降维，可以有效的避免过拟合
>
> 3.全连接层——根据不同任务输出我们想要的结果

## 6.RNN循环神经网络

> ​	循环神经网络通过使用带自反馈的神经元，能够处理任意长度的序列
>
> ​	循环神经网络比前馈神经网络更加f符合生物神经网络的结构
>
> ​	循环神经网络已经被广泛应用在语音识别、语言模型以及自然语言生成等任务上
>
> RNN跟神经网络最大的区别在于每次都会将前一次的输出结果，带到下一次的隐藏层中，一起训练

---

## 7.LSTM长期记忆神经网络

> 1.LSTM的产生原因
>
> ​	RNN在处理长期依赖(时间序列上距离较远的节点)时会遇到巨大的困难，因为距离较远的节点之间的联系时会设计雅可比矩阵的多次相乘，会造成梯度消失或者梯度膨胀的现象。其中最成功应用最广泛的就是门限RNN，而LSTM就是门限RNN中最著名的一种。有漏单元通过合计连接间的权重系数，从而允许RNN累积 距离较远节点间的长期联系；而门限RNN则泛化了这样的思想，允许在不同时刻改变该系数，且允许网络忘记当前已经累积的信息
>
> 2.RNN和LSTM的区别
>
> ​	所有RNN都具有一种重复神经网络模块的链式的形式。在标准的RNn中，这个重复的模块只有一个非常简单的结构。但LSTM同样是这样的结构，而重复的模块拥有一个不同的结构。不同于单一神经网络，这里是有四个，以一种非常特殊的方式进行交互
>
> 3.LSTM的核心
>
> ​	LSTM有通称作为“门“的结构来去除或者增加信息到细胞状态的能力。门是一种让信息选择式通过的方法。他们包含一个sigmoid神经网络层和一个pointwise乘法操作
>
> ​	LSTM拥有三个门，分别是遗忘门，输入层们和输出层门，来保护和控制细胞状态
>
> ​	忘记层门
>
> ​	作用对象：细胞状态
>
> ​	作用：将细胞状态中的信息选择性的遗忘
>
> ​	操作步骤：该门会读取ht-1和xt,输出一个在0到1之间的数值给每个在细胞状态Ct-1中的数字。1表示“完全保留”，0表示“完全舍弃”。
>
> ​	输入层门
>
> ​	作用对象